package school.javacore.multythreading;

/*
Часть 1: Демонстрация deadlock
Создайте два объекта-ресурса (например, Object resource1 и Object resource2).
Создайте два потока, где:
Поток A сначала захватывает resource1, затем пытается захватить resource2.
Поток B сначала захватывает resource2, затем пытается захватить resource1.
Запустите потоки и наблюдайте, что программа иногда зависает из-за взаимной блокировки.
Можно добавить паузу между захватами ресурсов, чтобы точно получить дедлок.
Добавьте вывод в консоль, чтобы видеть, какой поток захватывает какой ресурс.

Часть 2: Устранение deadlock
Модифицируйте программу так, чтобы оба потока захватывали ресурсы в одном и том же порядке.
Для этого создайте правило упорядочивания, например, используя идентификаторы ресурсов или условие,
которое определяет, какой объект должен быть захвачен первым.
Приведите пример кода, в котором два потока сначала захватывают ресурс с меньшим идентификатором,
а затем – ресурс с большим идентификатором.
*/
public class DeadlockLesson {
    public static void main(String[] args) {
        Object lock1 = new Object();
        Object lock2 = new Object();


        Thread A = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Первый поток захватил первый монитор");

                synchronized (lock2) {
                    System.out.println("Первый поток захватил второй монитор");
                }
            }
        });

        Thread B = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Второй поток захватил первый монитор");
                synchronized (lock2) {
                    System.out.println("Второй поток захватил второй монитор");
                }
            }
        });

        A.start();
        B.start();
    }
}
